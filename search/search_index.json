{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Lista/","text":"Listas Encadeadas O que \u00e9 uma lista Estrutura de dados din\u00e2mica que tem a capacidade de adicionar ou remover elementos sem mudar o lugar de outros elementos, n\u00e3o precisa definir um tamanho m\u00e1ximo com em vetores. Exemplos _____ _ |1|2|...|N| | |->Proximo |-> Dado Um dado N est\u00e1 sempre ligado \u00e0 um dado N+1 struct celula{ int dado; struct celula *prox; /* \u00c9 o ponteiro que aponta para o pr\u00f3ximo elemento que pode estar em qualquer lugar;*/ } int v[5]; // Aloca\u00e7\u00e3o autom\u00e1tica int *v = malloc(5*sizeof(int)); // Aloca\u00e7\u00e3o din\u00e2mica v[i]; Lista sem cabe\u00e7a: celula *l = NULL; Lista com cabe\u00e7a: celula *l = malloc(sizeof(celula)); |-> prox = NULL; Ex.: Fa\u00e7a uma fun\u00e7\u00e3o para imprimir o conte\u00fado de uma lista encadeado. void print_vetor(int v[], int n){ for(int i = 0; i < n ; i++){ printf(\"%d\", v[i]); } } void ptint_vetor(celula *l){ for(celula*p = l-> prox; p!= NULL; p = p -> prox){ printf(\"%d\", p=>dado) } } O custo de um algoritimo \u00e9 quanto tempo ele gasta em temos de entrada, quanto mais la\u00e7os maior o valor de O(N^i). Se tiver s\u00f3 um ciclo \u00e9 um algoritmo linear. Dependde de quantos Ciclos aninhados existem (Um for dentro de outro etc)","title":"Listas Encadeadas"},{"location":"Lista/#listas-encadeadas","text":"","title":"Listas Encadeadas"},{"location":"Lista/#o-que-e-uma-lista","text":"Estrutura de dados din\u00e2mica que tem a capacidade de adicionar ou remover elementos sem mudar o lugar de outros elementos, n\u00e3o precisa definir um tamanho m\u00e1ximo com em vetores.","title":"O que \u00e9 uma lista"},{"location":"Lista/#exemplos","text":"_____ _ |1|2|...|N| | |->Proximo |-> Dado Um dado N est\u00e1 sempre ligado \u00e0 um dado N+1 struct celula{ int dado; struct celula *prox; /* \u00c9 o ponteiro que aponta para o pr\u00f3ximo elemento que pode estar em qualquer lugar;*/ } int v[5]; // Aloca\u00e7\u00e3o autom\u00e1tica int *v = malloc(5*sizeof(int)); // Aloca\u00e7\u00e3o din\u00e2mica v[i]; Lista sem cabe\u00e7a: celula *l = NULL; Lista com cabe\u00e7a: celula *l = malloc(sizeof(celula)); |-> prox = NULL; Ex.: Fa\u00e7a uma fun\u00e7\u00e3o para imprimir o conte\u00fado de uma lista encadeado. void print_vetor(int v[], int n){ for(int i = 0; i < n ; i++){ printf(\"%d\", v[i]); } } void ptint_vetor(celula *l){ for(celula*p = l-> prox; p!= NULL; p = p -> prox){ printf(\"%d\", p=>dado) } } O custo de um algoritimo \u00e9 quanto tempo ele gasta em temos de entrada, quanto mais la\u00e7os maior o valor de O(N^i). Se tiver s\u00f3 um ciclo \u00e9 um algoritmo linear. Dependde de quantos Ciclos aninhados existem (Um for dentro de outro etc)","title":"Exemplos"},{"location":"Lista02/","text":"Lista type def struc celula{ int dado; struct celula *prox; } celula; celula *l = malloc(sizeof(celula)); int buscaVetor(int v[], int n, int x){ for(int = 0; i < n; i++){ if(v[i]==x){ return i; } } return -1; } O custo para inserir um elemento numa lista \u00e9 constante, e bem mais barato que num vetor, que \u00e9 linear. Em contrapartidada, acessar um elementonum vetor O(1), enquanto num vetor \u00e9 O(n). int removeVetor(int *v, int n){ int elem = v[0]; for(int i=1; i < n; i++){ v[i-1] = v[i]; } return elem; } int removeInicioLista(celula *l){ celula *lixo = l->prox; l->prox = lixo->prox; int elem = lixo -> dado; free(lixo); return elem; } int removeListaN(celula *l, int i){ // i >= 1 int elem, celula *p = l; for(int j = 0; j < i-1 && p != NULL; j++,p = p -> prox); if (p != NULL) return removeInicoLista(p); }","title":"Lista"},{"location":"Lista02/#lista","text":"type def struc celula{ int dado; struct celula *prox; } celula; celula *l = malloc(sizeof(celula)); int buscaVetor(int v[], int n, int x){ for(int = 0; i < n; i++){ if(v[i]==x){ return i; } } return -1; } O custo para inserir um elemento numa lista \u00e9 constante, e bem mais barato que num vetor, que \u00e9 linear. Em contrapartidada, acessar um elementonum vetor O(1), enquanto num vetor \u00e9 O(n). int removeVetor(int *v, int n){ int elem = v[0]; for(int i=1; i < n; i++){ v[i-1] = v[i]; } return elem; } int removeInicioLista(celula *l){ celula *lixo = l->prox; l->prox = lixo->prox; int elem = lixo -> dado; free(lixo); return elem; } int removeListaN(celula *l, int i){ // i >= 1 int elem, celula *p = l; for(int j = 0; j < i-1 && p != NULL; j++,p = p -> prox); if (p != NULL) return removeInicoLista(p); }","title":"Lista"},{"location":"Pilha/","text":"Pilhas Uma pilha \u00e9 uma estrutura linear para manipula\u00e7\u00e3o de dados que segue o esquema LIFO. Last in First out, ou seja, o \u00faltimo que entra \u00e9 o primeiro que sa\u00ed. 6 |\\| 5 |\\| |\\| |\\| 4 |\\| |\\| |\\| 3 |\\| |\\| |\\| 2 |\\| |\\| |\\| 1 |\\| |X| Desempilha |\\| 0 |X| Empilha(1)-> |1| Retorna 1 |X| X = Topo Pilha com vetores Declara\u00e7\u00e3o # define N 10 typedef struct pilha{ int dados[n]; int topo; } pilha; Cria\u00e7\u00e3o da pilha void criaPilha(pilha *p){ p-> topo = 0; } Empilha void empilha(pilha *p, int y){ p->dado[p->topo++]=y; } Pilha cheia int pilhaCheia(pilha *p){ return p-> topo == N; } Desempilha int desempilha (pilha *p){ return p->dado[--p->topo] } Pilha vazia int pilhaVazia(pilha *p){ return !p -> topo // If pilha vazia, p == 0 esle p != 0 } Obs.: - 1 Empilha s\u00f3 pode ser chamado se a pilha n\u00e3o estiver cheia - 2. Desempilha s\u00f3 pode ser chamado se a pilha n\u00e3o estiver vazia Criando um m\u00f3dulo para pilha de inteiros Um m\u00f3dulo \u00e9 um par de arquivos de mesmo nome com extens\u00e3o .h e .c, respectivamente. O arquivo .h \u00e9 chamado header file (arquivo interface) e contem prot\u00f3tipos de fun\u00e7oess. Um arqivo de nome .h possui o seguinte formato #define _nome.h #define _nome.h /*Prot\u00f3tipos e constantes*/ #endif O arquivo .c, por sua vez, possui as implementa\u00e7\u00f5es das fun\u00e7\u00f5es declaradas no .h pilhaInt.h #ifndef _pilhaInt.h #define _pilhaInt.h int criaPilha(); int empilha(int y); int desempilha(int *y); void destroiPilha(); #endif pilhaInt.c static int *pilha; static int N, topo; int criaPilha(){ N=10; pilha = malloc(N*sizeof(int)); pilha==NULL ? return 0:return 1; } int empilha(int y){ if(topo == N){ if((pilha = realloc(pilha, 2*N))==NULL) return 0; N*=2; } pilha[topo++]=y; return 1; } int desempilha(int *y){ if(!topo) return 0; *y = pilha[--topo]; return 0; } void destroiPilha(){ free(pilha); } main #include \"pilhaInt.h\" Compilar gcc -o main main.c pilhaInt.c","title":"Pilhas"},{"location":"Pilha/#pilhas","text":"Uma pilha \u00e9 uma estrutura linear para manipula\u00e7\u00e3o de dados que segue o esquema LIFO. Last in First out, ou seja, o \u00faltimo que entra \u00e9 o primeiro que sa\u00ed. 6 |\\| 5 |\\| |\\| |\\| 4 |\\| |\\| |\\| 3 |\\| |\\| |\\| 2 |\\| |\\| |\\| 1 |\\| |X| Desempilha |\\| 0 |X| Empilha(1)-> |1| Retorna 1 |X| X = Topo","title":"Pilhas"},{"location":"Pilha/#pilha-com-vetores","text":"","title":"Pilha com vetores"},{"location":"Pilha/#declaracao","text":"# define N 10 typedef struct pilha{ int dados[n]; int topo; } pilha; Cria\u00e7\u00e3o da pilha void criaPilha(pilha *p){ p-> topo = 0; } Empilha void empilha(pilha *p, int y){ p->dado[p->topo++]=y; } Pilha cheia int pilhaCheia(pilha *p){ return p-> topo == N; } Desempilha int desempilha (pilha *p){ return p->dado[--p->topo] } Pilha vazia int pilhaVazia(pilha *p){ return !p -> topo // If pilha vazia, p == 0 esle p != 0 } Obs.: - 1 Empilha s\u00f3 pode ser chamado se a pilha n\u00e3o estiver cheia - 2. Desempilha s\u00f3 pode ser chamado se a pilha n\u00e3o estiver vazia","title":"Declara\u00e7\u00e3o"},{"location":"Pilha/#criando-um-modulo-para-pilha-de-inteiros","text":"Um m\u00f3dulo \u00e9 um par de arquivos de mesmo nome com extens\u00e3o .h e .c, respectivamente. O arquivo .h \u00e9 chamado header file (arquivo interface) e contem prot\u00f3tipos de fun\u00e7oess. Um arqivo de nome .h possui o seguinte formato #define _nome.h #define _nome.h /*Prot\u00f3tipos e constantes*/ #endif O arquivo .c, por sua vez, possui as implementa\u00e7\u00f5es das fun\u00e7\u00f5es declaradas no .h","title":"Criando um m\u00f3dulo para pilha de inteiros"},{"location":"Pilha/#pilhainth","text":"#ifndef _pilhaInt.h #define _pilhaInt.h int criaPilha(); int empilha(int y); int desempilha(int *y); void destroiPilha(); #endif","title":"pilhaInt.h"},{"location":"Pilha/#pilhaintc","text":"static int *pilha; static int N, topo; int criaPilha(){ N=10; pilha = malloc(N*sizeof(int)); pilha==NULL ? return 0:return 1; } int empilha(int y){ if(topo == N){ if((pilha = realloc(pilha, 2*N))==NULL) return 0; N*=2; } pilha[topo++]=y; return 1; } int desempilha(int *y){ if(!topo) return 0; *y = pilha[--topo]; return 0; } void destroiPilha(){ free(pilha); }","title":"pilhaInt.c"},{"location":"Pilha/#main","text":"#include \"pilhaInt.h\"","title":"main"},{"location":"Pilha/#compilar","text":"gcc -o main main.c pilhaInt.c","title":"Compilar"}]}